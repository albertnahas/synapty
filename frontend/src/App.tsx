import React, { useState, useCallback } from 'react';
import MindMapVisualization from './components/MindMapVisualization';
import { apiService } from './api';
import { Node, Edge } from './types';
import PptxGenJS from 'pptxgenjs';

function App() {
  const [topic, setTopic] = useState('');
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);
  const [loading, setLoading] = useState(false);
  const [hoveredNode, setHoveredNode] = useState<Node | null>(null);
  const [selectedNode, setSelectedNode] = useState<Node | null>(null);
  const [expanding, setExpanding] = useState(false);

  const handleGenerateGraph = useCallback(async () => {
    if (!topic.trim()) return;

    setLoading(true);
    try {
      const graphData = await apiService.generateGraph(topic.trim());
      setNodes(graphData.nodes);
      setEdges(graphData.edges);
    } catch (error) {
      console.error('Error generating graph:', error);
      alert('Failed to generate graph. Please try again.');
    } finally {
      setLoading(false);
    }
  }, [topic]);

  const handleNodeClick = useCallback((node: Node) => {
    setSelectedNode(node);
  }, []);

  const handleNodeHover = useCallback((node: Node | null) => {
    setHoveredNode(node);
  }, []);

  const handleExpandNode = useCallback(async () => {
    if (!selectedNode || expanding) return;

    setExpanding(true);
    try {
      const expansion = await apiService.expandNode(selectedNode.id, selectedNode.title);
      
      // Update positions of new nodes relative to parent
      const updatedNodes = expansion.nodes.map(node => ({
        ...node,
        position: {
          x: selectedNode.position.x + node.position.x,
          y: selectedNode.position.y + node.position.y,
          z: selectedNode.position.z + node.position.z,
        }
      }));

      setNodes(prevNodes => [...prevNodes, ...updatedNodes]);
      setEdges(prevEdges => [...prevEdges, ...expansion.edges]);
    } catch (error) {
      console.error('Error expanding node:', error);
      alert('Failed to expand node. Please try again.');
    } finally {
      setExpanding(false);
    }
  }, [selectedNode, expanding]);

  const handleReset = useCallback(() => {
    setNodes([]);
    setEdges([]);
    setSelectedNode(null);
    setHoveredNode(null);
    setTopic('');
  }, []);

  const handleExportJSON = useCallback(() => {
    const exportData = {
      topic,
      nodes,
      edges,
      timestamp: new Date().toISOString(),
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], {
      type: 'application/json',
    });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `synapty-${topic.replace(/\s+/g, '-').toLowerCase()}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }, [topic, nodes, edges]);

  const handleExportPPTX = useCallback(async () => {
    const pptx = new PptxGenJS();
    
    // Title slide
    const slide1 = pptx.addSlide();
    slide1.addText(topic, {
      x: 1,
      y: 2,
      w: 8,
      h: 2,
      fontSize: 36,
      bold: true,
      align: 'center',
      color: '363636'
    });
    slide1.addText('Generated by Synapty', {
      x: 1,
      y: 4,
      w: 8,
      h: 1,
      fontSize: 18,
      align: 'center',
      color: '666666'
    });

    // Create slides for each main concept (level 1 nodes)
    const mainNodes = nodes.filter(node => node.level === 1);
    
    for (const node of mainNodes) {
      const slide = pptx.addSlide();
      
      // Node title
      slide.addText(node.title, {
        x: 1,
        y: 0.5,
        w: 8,
        h: 1,
        fontSize: 28,
        bold: true,
        color: '4ecdc4'
      });
      
      // Node summary
      slide.addText(node.summary, {
        x: 1,
        y: 2,
        w: 8,
        h: 2,
        fontSize: 16,
        color: '363636'
      });
      
      // Add child nodes if any
      const childNodes = nodes.filter(n => n.parent === node.id);
      if (childNodes.length > 0) {
        slide.addText('Key Points:', {
          x: 1,
          y: 4.5,
          w: 8,
          h: 0.5,
          fontSize: 18,
          bold: true,
          color: '363636'
        });
        
        childNodes.forEach((child, index) => {
          slide.addText(`â€¢ ${child.title}: ${child.summary}`, {
            x: 1.5,
            y: 5 + (index * 0.8),
            w: 7,
            h: 0.8,
            fontSize: 14,
            color: '666666'
          });
        });
      }
    }

    // Save the presentation
    await pptx.writeFile({ fileName: `synapty-${topic.replace(/\s+/g, '-').toLowerCase()}.pptx` });
  }, [topic, nodes]);

  const displayNode = hoveredNode || selectedNode;

  return (
    <div className="App" style={{ width: '100vw', height: '100vh', position: 'relative' }}>
      {/* 3D Visualization */}
      <MindMapVisualization
        nodes={nodes}
        edges={edges}
        onNodeClick={handleNodeClick}
        onNodeHover={handleNodeHover}
        selectedNodeId={selectedNode?.id}
      />

      {/* UI Overlay */}
      <div className="ui-overlay">
        {/* Input Panel */}
        <div className="input-panel">
          <h1>Synapty</h1>
          <div className="input-group">
            <input
              type="text"
              className="topic-input"
              placeholder="Enter any topic to explore..."
              value={topic}
              onChange={(e) => setTopic(e.target.value)}
              onKeyPress={(e) => e.key === 'Enter' && handleGenerateGraph()}
              disabled={loading}
            />
            <button
              className="generate-btn"
              onClick={handleGenerateGraph}
              disabled={loading || !topic.trim()}
            >
              {loading ? 'Generating...' : 'Generate'}
            </button>
          </div>
          {loading && <div className="loading">Creating your mindmap...</div>}
        </div>

        {/* Node Information Panel */}
        {displayNode && (
          <div className={`node-info ${displayNode ? 'visible' : ''}`}>
            <h3>{displayNode.title}</h3>
            <p>{displayNode.summary}</p>
            {selectedNode && selectedNode.id !== 'center' && (
              <button
                className="expand-btn"
                onClick={handleExpandNode}
                disabled={expanding}
              >
                {expanding ? 'Expanding...' : '+ Expand'}
              </button>
            )}
          </div>
        )}

        {/* Controls Panel */}
        {nodes.length > 0 && (
          <div className="controls-panel">
            <button className="control-btn" onClick={handleReset}>
              Reset
            </button>
            <button className="control-btn" onClick={handleExportJSON}>
              Export JSON
            </button>
            <button className="control-btn" onClick={handleExportPPTX}>
              Export PPTX
            </button>
          </div>
        )}
      </div>
    </div>
  );
}

export default App;